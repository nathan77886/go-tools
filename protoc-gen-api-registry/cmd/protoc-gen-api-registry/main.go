package main

import (
	"flag"
	"fmt"
	annotations "github.com/nathan77886/go-tools/protoc-gen-api-registry/proto/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"

	runtime "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/proto"
)

type apiMeta struct {
	Service   string
	Method    string
	Path      string
	Verb      string
	Group     string
	WhiteList bool
}

func main() {
	var flags flag.FlagSet
	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(plugin *protogen.Plugin) error {
		var apis []apiMeta

		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			for _, service := range file.Services {
				for _, method := range service.Methods {
					opts := method.Desc.Options().(*descriptorpb.MethodOptions)
					if opts == nil || !opts.ProtoReflect().IsValid() {
						continue
					}

					// google.api.http
					httpRule := getHTTPRule(opts)
					if httpRule == nil {
						continue
					}

					path, verb := extractHTTP(httpRule)

					// annotations.white_list
					white := false
					if proto.HasExtension(opts, annotations.E_WhiteList) {
						v, ok := proto.GetExtension(opts, annotations.E_WhiteList).(bool)
						if ok {
							white = v
						}
					}

					apis = append(apis, apiMeta{
						Service:   string(service.Desc.Name()),
						Method:    string(method.Desc.Name()),
						Path:      path,
						Verb:      verb,
						Group:     string(service.Desc.Name()),
						WhiteList: white,
					})
				}
			}
			filename := file.GeneratedFilenamePrefix + "_api_registry.pb.go"
			f := plugin.NewGeneratedFile(filename, file.GoImportPath)
			writeHeader(f, string(file.GoPackageName))
			writeApiList(f, apis)
		}
		return nil
	})
}

func getHTTPRule(opts *descriptorpb.MethodOptions) *runtime.HttpRule {
	if proto.HasExtension(opts, runtime.E_Http) {
		if v, ok := proto.GetExtension(opts, runtime.E_Http).(*runtime.HttpRule); ok {
			return v
		}
	}
	return nil
}

func extractHTTP(rule *runtime.HttpRule) (string, string) {
	switch pattern := rule.Pattern.(type) {
	case *runtime.HttpRule_Get:
		return pattern.Get, "GET"
	case *runtime.HttpRule_Post:
		return pattern.Post, "POST"
	case *runtime.HttpRule_Put:
		return pattern.Put, "PUT"
	case *runtime.HttpRule_Delete:
		return pattern.Delete, "DELETE"
	case *runtime.HttpRule_Patch:
		return pattern.Patch, "PATCH"
	default:
		return "", ""
	}
}

func writeHeader(g *protogen.GeneratedFile, packageName string) {
	g.P("// Code generated by protoc-gen-api-registry. DO NOT EDIT.")
	g.P("\npackage ", packageName, "\n")
	g.P("type ApiRoute struct {")
	g.P("\tService string")
	g.P("\tMethod string")
	g.P("\tPath string")
	g.P("\tHTTPVerb string")
	g.P("\tGroup string")
	g.P("\tWhiteList bool")
	g.P("}")
}

func writeApiList(g *protogen.GeneratedFile, apis []apiMeta) {
	g.P("\nvar ApiList = []ApiRoute{")
	for _, a := range apis {
		g.P(fmt.Sprintf("\t{Service: \"%s\", Method: \"%s\", Path: \"%s\", HTTPVerb: \"%s\", Group: \"%s\", WhiteList: %t},",
			a.Service, a.Method, a.Path, a.Verb, a.Group, a.WhiteList))
	}
	g.P("}")
}
